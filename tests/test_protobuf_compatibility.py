"""Protobuf compatibility tests for Meshtastic package versions.

These tests verify that the protobuf messages generated by this tool
are compatible with the Meshtastic protocol specification and can be
properly deserialized using the official meshtastic package.
"""

import unittest
from src.meshtastic_mqtt_protobuf.message import (
    build_protobuf_message,
    parse_node_id,
    generate_packet_id
)

# Import protobuf modules
from meshtastic import mesh_pb2, mqtt_pb2, portnums_pb2
import meshtastic


class TestMeshtasticPackageVersion(unittest.TestCase):
    """Test compatibility with current meshtastic package version."""
    
    def test_meshtastic_package_installed(self):
        """Verify meshtastic package is installed and accessible."""
        # Verify we can import the package and its modules
        self.assertIsNotNone(meshtastic)
        self.assertIsNotNone(mesh_pb2)
        self.assertIsNotNone(mqtt_pb2)
        self.assertIsNotNone(portnums_pb2)
        
        # Try to get version if available
        if hasattr(meshtastic, '__version__'):
            print(f"\nTesting with meshtastic package version: {meshtastic.__version__}")
        else:
            print("\nTesting with meshtastic package (version not available via __version__)")
    
    def test_required_protobuf_modules(self):
        """Verify all required protobuf modules are available."""
        # Check mesh_pb2 module
        self.assertTrue(hasattr(mesh_pb2, 'MeshPacket'))
        self.assertTrue(hasattr(mesh_pb2, 'Data'))
        
        # Check mqtt_pb2 module
        self.assertTrue(hasattr(mqtt_pb2, 'ServiceEnvelope'))
        
        # Check portnums_pb2 module
        self.assertTrue(hasattr(portnums_pb2, 'PortNum'))
        self.assertTrue(hasattr(portnums_pb2.PortNum, 'TEXT_MESSAGE_APP'))
    
    def test_protobuf_field_compatibility(self):
        """Verify protobuf message fields match expected structure."""
        # Create a ServiceEnvelope
        envelope = mqtt_pb2.ServiceEnvelope()
        
        # Verify ServiceEnvelope has required fields
        self.assertTrue(hasattr(envelope, 'packet'))
        self.assertTrue(hasattr(envelope, 'channel_id'))
        self.assertTrue(hasattr(envelope, 'gateway_id'))
        
        # Create a MeshPacket
        packet = mesh_pb2.MeshPacket()
        
        # Verify MeshPacket has required fields
        # Note: 'from' is accessed via getattr since it's a Python keyword
        self.assertTrue(hasattr(packet, 'to'))
        self.assertTrue(hasattr(packet, 'id'))
        self.assertTrue(hasattr(packet, 'channel'))
        self.assertTrue(hasattr(packet, 'hop_limit'))
        self.assertTrue(hasattr(packet, 'want_ack'))
        self.assertTrue(hasattr(packet, 'decoded'))
        
        # Create a Data message
        data = mesh_pb2.Data()
        
        # Verify Data has required fields
        self.assertTrue(hasattr(data, 'portnum'))
        self.assertTrue(hasattr(data, 'payload'))


class TestProtobufSerializationDeserialization(unittest.TestCase):
    """Test protobuf serialization and deserialization round-trip."""
    
    def test_roundtrip_broadcast_message(self):
        """Test serialization and deserialization of broadcast message."""
        # Original parameters
        text = "Test broadcast message"
        to_id = "^all"
        gateway_id = "!12345678"
        channel = "LongFast"
        want_ack = False
        hop_limit = 3
        
        # Build protobuf message
        protobuf_bytes = build_protobuf_message(
            text=text,
            to_id=to_id,
            gateway_id=gateway_id,
            channel=channel,
            want_ack=want_ack,
            hop_limit=hop_limit
        )
        
        # Deserialize
        envelope = mqtt_pb2.ServiceEnvelope()
        envelope.ParseFromString(protobuf_bytes)
        
        # Verify all fields match
        self.assertEqual(envelope.channel_id, channel)
        self.assertEqual(envelope.gateway_id, gateway_id)
        self.assertEqual(envelope.packet.to, parse_node_id(to_id))
        self.assertEqual(envelope.packet.hop_limit, hop_limit)
        self.assertEqual(envelope.packet.want_ack, want_ack)
        self.assertEqual(envelope.packet.decoded.portnum, portnums_pb2.PortNum.TEXT_MESSAGE_APP)
        self.assertEqual(envelope.packet.decoded.payload.decode('utf-8'), text)
    
    def test_roundtrip_direct_message(self):
        """Test serialization and deserialization of direct message."""
        text = "Direct message test"
        to_id = "!87654321"
        gateway_id = "!abcdef12"
        channel = "ShortSlow"
        want_ack = True
        hop_limit = 5
        
        # Build and deserialize
        protobuf_bytes = build_protobuf_message(
            text=text,
            to_id=to_id,
            gateway_id=gateway_id,
            channel=channel,
            want_ack=want_ack,
            hop_limit=hop_limit
        )
        
        envelope = mqtt_pb2.ServiceEnvelope()
        envelope.ParseFromString(protobuf_bytes)
        
        # Verify fields
        self.assertEqual(envelope.channel_id, channel)
        self.assertEqual(envelope.gateway_id, gateway_id)
        self.assertEqual(envelope.packet.to, parse_node_id(to_id))
        self.assertEqual(envelope.packet.hop_limit, hop_limit)
        self.assertEqual(envelope.packet.want_ack, want_ack)
        self.assertEqual(envelope.packet.decoded.payload.decode('utf-8'), text)
    
    def test_roundtrip_unicode_message(self):
        """Test serialization and deserialization with Unicode text."""
        text = "Hello ‰∏ñÁïå! üåç √âmojis and sp√´cial √ßhars"
        
        protobuf_bytes = build_protobuf_message(
            text=text,
            to_id="^all",
            gateway_id="!12345678",
            channel="LongFast"
        )
        
        envelope = mqtt_pb2.ServiceEnvelope()
        envelope.ParseFromString(protobuf_bytes)
        
        # Verify Unicode is preserved
        decoded_text = envelope.packet.decoded.payload.decode('utf-8')
        self.assertEqual(decoded_text, text)
    
    def test_roundtrip_long_message(self):
        """Test serialization and deserialization with long text."""
        # Create a message near the typical limit
        text = "A" * 200  # 200 characters
        
        protobuf_bytes = build_protobuf_message(
            text=text,
            to_id="^all",
            gateway_id="!12345678",
            channel="LongFast"
        )
        
        envelope = mqtt_pb2.ServiceEnvelope()
        envelope.ParseFromString(protobuf_bytes)
        
        # Verify long text is preserved
        decoded_text = envelope.packet.decoded.payload.decode('utf-8')
        self.assertEqual(decoded_text, text)
        self.assertEqual(len(decoded_text), 200)


class TestProtobufMessageValidation(unittest.TestCase):
    """Test that generated messages conform to Meshtastic protocol."""
    
    def test_packet_id_uniqueness(self):
        """Verify packet IDs are unique across multiple messages."""
        packet_ids = set()
        
        for i in range(100):
            protobuf_bytes = build_protobuf_message(
                text=f"Message {i}",
                to_id="^all",
                gateway_id="!12345678",
                channel="LongFast"
            )
            
            envelope = mqtt_pb2.ServiceEnvelope()
            envelope.ParseFromString(protobuf_bytes)
            packet_ids.add(envelope.packet.id)
        
        # All packet IDs should be unique
        self.assertEqual(len(packet_ids), 100)
    
    def test_packet_id_range(self):
        """Verify packet IDs are within valid 32-bit range."""
        for _ in range(10):
            packet_id = generate_packet_id()
            self.assertGreaterEqual(packet_id, 0)
            self.assertLessEqual(packet_id, 0xFFFFFFFF)
    
    def test_node_id_parsing_consistency(self):
        """Verify node ID parsing is consistent."""
        test_cases = [
            ("!12345678", 0x12345678),
            ("!abcdef12", 0xabcdef12),
            ("!ABCDEF12", 0xABCDEF12),
            ("^all", 0xFFFFFFFF),
            ("^ALL", 0xFFFFFFFF),
        ]
        
        for node_id_str, expected_int in test_cases:
            result = parse_node_id(node_id_str)
            self.assertEqual(result, expected_int)
    
    def test_channel_index_default(self):
        """Verify channel index is set to 0 (default channel)."""
        protobuf_bytes = build_protobuf_message(
            text="Test",
            to_id="^all",
            gateway_id="!12345678",
            channel="LongFast"
        )
        
        envelope = mqtt_pb2.ServiceEnvelope()
        envelope.ParseFromString(protobuf_bytes)
        
        # Channel index should be 0 for default channel
        self.assertEqual(envelope.packet.channel, 0)
    
    def test_portnum_text_message(self):
        """Verify portnum is set to TEXT_MESSAGE_APP."""
        protobuf_bytes = build_protobuf_message(
            text="Test",
            to_id="^all",
            gateway_id="!12345678",
            channel="LongFast"
        )
        
        envelope = mqtt_pb2.ServiceEnvelope()
        envelope.ParseFromString(protobuf_bytes)
        
        # Portnum should be TEXT_MESSAGE_APP (value 1)
        self.assertEqual(envelope.packet.decoded.portnum, portnums_pb2.PortNum.TEXT_MESSAGE_APP)
        self.assertEqual(envelope.packet.decoded.portnum, 1)
    
    def test_from_field_set_correctly(self):
        """Verify 'from' field is set to gateway ID."""
        gateway_id = "!abcd1234"
        
        protobuf_bytes = build_protobuf_message(
            text="Test",
            to_id="^all",
            gateway_id=gateway_id,
            channel="LongFast"
        )
        
        envelope = mqtt_pb2.ServiceEnvelope()
        envelope.ParseFromString(protobuf_bytes)
        
        # 'from' field should match gateway ID
        self.assertEqual(getattr(envelope.packet, 'from'), parse_node_id(gateway_id))
    
    def test_hop_limit_boundaries(self):
        """Verify hop limit values at boundaries."""
        test_values = [0, 1, 3, 7]
        
        for hop_limit in test_values:
            protobuf_bytes = build_protobuf_message(
                text="Test",
                to_id="^all",
                gateway_id="!12345678",
                channel="LongFast",
                hop_limit=hop_limit
            )
            
            envelope = mqtt_pb2.ServiceEnvelope()
            envelope.ParseFromString(protobuf_bytes)
            
            self.assertEqual(envelope.packet.hop_limit, hop_limit)
    
    def test_want_ack_boolean_values(self):
        """Verify want_ack accepts boolean values."""
        for want_ack in [True, False]:
            protobuf_bytes = build_protobuf_message(
                text="Test",
                to_id="^all",
                gateway_id="!12345678",
                channel="LongFast",
                want_ack=want_ack
            )
            
            envelope = mqtt_pb2.ServiceEnvelope()
            envelope.ParseFromString(protobuf_bytes)
            
            self.assertEqual(envelope.packet.want_ack, want_ack)


class TestProtobufBinaryFormat(unittest.TestCase):
    """Test binary format characteristics of protobuf messages."""
    
    def test_message_is_binary(self):
        """Verify generated message is binary bytes."""
        protobuf_bytes = build_protobuf_message(
            text="Test",
            to_id="^all",
            gateway_id="!12345678",
            channel="LongFast"
        )
        
        self.assertIsInstance(protobuf_bytes, bytes)
        self.assertGreater(len(protobuf_bytes), 0)
    
    def test_message_size_reasonable(self):
        """Verify message size is reasonable for text messages."""
        text = "Hello Mesh!"
        
        protobuf_bytes = build_protobuf_message(
            text=text,
            to_id="^all",
            gateway_id="!12345678",
            channel="LongFast"
        )
        
        # Message should be larger than text but not excessively large
        # Typical overhead is 30-50 bytes for protobuf structure
        self.assertGreater(len(protobuf_bytes), len(text))
        self.assertLess(len(protobuf_bytes), len(text) + 100)
    
    def test_message_deterministic_structure(self):
        """Verify messages with same content have consistent structure."""
        text = "Deterministic test"
        
        # Build same message twice
        msg1 = build_protobuf_message(
            text=text,
            to_id="^all",
            gateway_id="!12345678",
            channel="LongFast",
            want_ack=False,
            hop_limit=3
        )
        
        msg2 = build_protobuf_message(
            text=text,
            to_id="^all",
            gateway_id="!12345678",
            channel="LongFast",
            want_ack=False,
            hop_limit=3
        )
        
        # Deserialize both
        env1 = mqtt_pb2.ServiceEnvelope()
        env1.ParseFromString(msg1)
        
        env2 = mqtt_pb2.ServiceEnvelope()
        env2.ParseFromString(msg2)
        
        # Structure should be identical except for packet ID
        self.assertEqual(env1.channel_id, env2.channel_id)
        self.assertEqual(env1.gateway_id, env2.gateway_id)
        self.assertEqual(env1.packet.to, env2.packet.to)
        self.assertEqual(env1.packet.hop_limit, env2.packet.hop_limit)
        self.assertEqual(env1.packet.want_ack, env2.packet.want_ack)
        self.assertEqual(env1.packet.decoded.payload, env2.packet.decoded.payload)
        
        # Packet IDs should be different
        self.assertNotEqual(env1.packet.id, env2.packet.id)


if __name__ == '__main__':
    unittest.main()
